# Swift Lotto 🎱

> 이번 Swift 로또 미션은, 아래 5가지의 흐름으로 진행하고 기록한다.
> 

<br>
<br>

## 1. 왜 스위프트를 선택했는가?

우테코 3주차 로또 미션을 자바로 구현하면서, 나는 **도메인 설계, Inside-Out, TDD 등**에 꽤 많은 고민을 쏟았다. 하지만 이 번 오픈 미션에서는 똑같은 “로또”라는 문제를, **완전히 다른 언어인 스위프트와 이에 맞는 철학** 위에서 구현해보면서 내가 가지고 있는 언어와 객체지향의 원리의 장, 단점을 배워보고 싶었다.

스위프트를 선택한 이유를 정리하면:

1. 순수 객체지향 철학을 가진 자바만 써오다 보니, 내가 당연하게 여기던 “객체지향적인 설계”가 정말 항상 좋은 선택인지 궁금했다. 그래서 함수형·프로토콜 지향·값 타입이 섞여 있는 Swift를 써 보면서 **객체지향의 강점과 한계를 바깥쪽에서 다시 바라보고 싶었다.**
2. 자바식 설계 원칙을 그대로 이식하는 게 아니라, **스위프트가 권장하는 “Swifty한 스타일”이 무엇인지** 직접 느껴보고 싶었다. 언어가 나에게 요구하는 사고방식(값 타입 중심, 옵셔널, 프로토콜 지향 등)을 몸으로 익혀보고, 도메인 설계를 거기에 어떻게 녹일 수 있을지 실험해 보고 싶었다.
3. Swift는 자바에 비해 레퍼런스나 예제가 상대적으로 적다고 느꼈다. 그래서 공식 문서와 몇 안 되는 자료들만으로 **학습 계획을 스스로 세우고, 작은 단위 목표를 쪼개서 달성하는 연습**을 해보고 싶었다. 단순히 “검색하면 다 나오는 언어”가 아니라, **스스로 길을 그려가야 하는 환경에서 얼마나 배울 수 있는지**도 확인해 보고 싶었다.
4. 예전에 실제 앱을 출시할 때 iOS 클라이언트 개발자와 협업을 해본 적이 있다. 그때 “서버/백엔드 쪽 시선”만으로는 이해하지 못하는 부분들이 분명히 있다는 걸 느꼈다. 이번 기회에 직접 Swift를 만져보면서, **앞으로 클라이언트 개발자들과 소통할 때 기반이 되는 공통 언어**를 조금이라도 가져가고 싶었다.
5. 언젠가는 **혼자서 작은 앱 하나를 처음부터 끝까지 만들어 보고 싶다**는 욕심도 있다. 이번 Swift 로또 도전은, 나에게는 “실제 앱 개발로 가기 전, 스위프트 생태계를 맛보는 첫 실험”에 가깝다.
6. 무엇보다, 미션의 취지(도전 정신)에 맞게 **“새로운 언어(Swift) + IDE(Xcode) + iOS UI 프레임워크(Storyboard 기반 UIKit)”**을 한꺼번에 부딪혀 보고 싶었다.  

그래서 목표를 이렇게 잡았다.

> 1차 목표: **Storyboard 기반으로 로또 기본 기능이 동작하는 iOS 앱 만들기**
> 
> 2차 목표: **MVVM 구조로 화면과 도메인 로직을 분리·리팩터링하기**
> 
> 3차 목표: **실제 로또 당첨 번호 데이터를 크롤링해서 앱에 연동해 보기**
<br>
<br>

## 2. 스위프트가 자바가 다른 점이 무엇일까?

(이곳에 Swift와 Java의 철학, 문법, 패러다임 차이점에 대한 분석 내용을 채워나갈 예정)

<br>
<br>

## 3. 미션의 목표와 한계

(이곳에 이번 미션을 통해 달성하고자 하는 구체적인 학습 목표와 시간/환경적 한계를 명시할 예정)

<br>
<br>

## ~~4. 첫 번째 목표: Swift로 콘솔 로또 게임 구현~~

원래는 자바와 마찬가지로 **콘솔 기반 로또 게임을 Swift로 먼저 옮겨보는 것**을 목표로 잡았으나, Xcode에서 기본으로 제공하는 템플릿이 iOS 앱(Storyboard/SwiftUI 기반)이라 별도의 콘솔 프로젝트 구성이 필요했다.  

이번에는 **iOS UI 구현에 집중**하기로 하여 콘솔 버전 단계는 생략하고, 바로 Storyboard 기반 로또 앱 구현(5번)으로 넘어가기로 했다.

<br>
<br>

## 5. 두 번째 목표: storyboard로 로또 UI 만들어보기

### 5-1. 콘솔창이... 없다? (Xcode와의 첫 만남)

자바 개발자인 나에게 '프로그래밍의 시작'은 언제나 `public static void main`이었고, 결과 확인은 검은색 콘솔창(Terminal)이었다. **그래서 처음엔 이번 로또 미션도 Swift로 간단하게 콘솔창에서 입출력을 받는 버전을 먼저 만들려고 했다.**

하지만 Xcode를 처음 켜고 프로젝트를 생성했을 때, 입출력을 담당하는 그 '검은색 콘솔창'이라는 개념 자체가 애초에 보이지 않았고, `ViewController`, `AppDelegate`, `SceneDelegate` 같은 낯선 파일만 있었다. 심지어 `System.out.println`을 어디에 찍어야 하는지도 막막했다.

내가 짠 코드가 콘솔이 아닌 '아이폰 시뮬레이터'라는 가상의 기계 위에서 돌아간다는 사실을 받아들이는 것부터가 시작이었다. 이걸 이해하고 나서야, 나는 자바에서 하던 방식(도메인 → main → 콘솔 I/O)을 잠시 내려놓고, **화면(ViewController)부터 한번 따라가 보자**” 라는 마음으로 방향을 틀었다.

<br>

### 5-2. 그림 그리기인가, 코딩인가? (Storyboard의 충격)

그다음 문화 충격은 **Storyboard**였다. 자바나 Spring에서는 모든 흐름이 온전히 코드 안에서 결정된다. 함수 호출, 객체 주입, 흐름 제어 같은 것들은 전부 키보드 위에서 이뤄졌다. 그런데 iOS에서는 시작부터 방식이 달랐다. 오브젝트(버튼이나 입력창)를 마우스로 드래그 앤 드롭해서 화면에 올려두고, 다시 그 요소들을 `@IBOutlet`, `@IBAction`과 같은 형태로 컨트롤 드래그로 코드에 연결해 줘야 했다.

이러한 연결은 단순한 “편의 기능”이 아니었다. `@IBOutlet` 프로퍼티만 선언해 두고 Storyboard에서 실제 코드와 매핑을 해두지 않으면, 빌드나 실행 과정에서 연결되지 않은 아울릿에 대한 예외가 발생하면서 앱이 그대로 죽어버렸다. Storyboard 위에 버튼을 올려놓았더라도, `@IBAction`으로 액션을 묶어두지 않으면 실제 앱에서는 버튼을 눌러도 아무 동작도 일어나지 않았다. 화면에 **“보이기만 하는 버튼”**과 **“실제로 반응하는 버튼”**이 완전히 다른 존재라는 것을 알게 되었다.

레이아웃을 잡는 과정에서 말하는 ‘체이닝’도 마찬가지였다. 입력창 옆에 버튼이 오도록 배치하고 싶다면, 또다시 컨트롤 드래그로 두 요소 사이에 **‘제약(Constraint)’**이라는 보이지 않는 선을 걸어줘야 했다. 로또 앱의 흐름이 버튼, 텍스트 필드(입력창), 레이블 등 여러 UI 요소들로 체인처럼 이어지다 보니, 이 연결 관계를 하나라도 빼먹거나 잘못 걸어두면 버튼은 화면 밖으로 밀려나고, 레이블은 서로 꼬이면서 화면이 엉망이 되었다.

**결국** 이 모든 그림판이 제멋대로처럼 느껴졌다. 스토리보드 캔버스에 보이는 이미지만 보면 레이아웃이 그럴듯해 보이는데, 막상 시뮬레이터를 켜면 실제 렌더링된 결과는 전혀 다른 모습으로 나타났다. 제약(Constraint)이 하나라도 빠지거나 꼬이면, 스토리보드에서 본 것과는 전혀 다른 화면이 펼쳐지는 경험을 여러 번 반복해야 했다.

이 과정 속에서, iOS 개발에서는 ‘보이는 화면’과 ‘코드로 작성된 논리’를 둘 다 관리하고, 둘 사이의 연결 상태까지 끝까지 책임져야 한다는 것을 알게되었다.

<br>

### 5-3. "Swifty"한 문법을 몸으로 느끼기

처음 Swift로 코드를 짤 때는, 솔직히 말하면 거의 Java 코드와 비슷하다고 느꼈다. 변수 타입의 순서만 바꾸고, 세미콜론만 지운 것 같은 느낌이었다. 그런데 로또 미션을 진행하면서, "아, 이 언어는 생각하는 방식 자체가 다르구나"를 몸으로 느낀 순간이 몇 번 있었다.

**첫 번째는 체이닝(Chaining)이었다.** 자바였다면 로또 번호를 출력하기 위해 `StringBuilder`를 만들고, 반복문을 돌면서 `append`를 호출했을 것이다. 하지만 Swift에서는 자연스럽게 이런 코드가 나왔다.

```swift
let ticketsText = lottos
    .map { "[\($0.getNumbers().map { String($0) }.joined(separator: ", "))]" }
    .joined(separator: "\n")
```

`map`으로 변환하고, 그 안에서 다시 `map`/`joined`를 쓰고, 마지막에 또 `joined`로 묶는 이 방식. `+`로 문자열을 계속 "더한다"기보다, `\()`(문자열 보간)를 이용해 데이터를 **"변환해서 흘려보내는"** 쪽에 가까웠다.

**두 번째는 `struct`였다.** `struct`도 처음에는 당황스러웠다. 자바에서는 `LottoTicket.java` 파일 안에 `public class LottoTicket`이 있는 것이 당연했는데, Swift에서는 그냥 `LottoTicket.swift` 파일 안에 `struct LottoTicket` 하나만 있어도 아무 문제가 없었다.

<br>


### 5-4. "Swifty"한 문법 2: 거꾸로 뒤집힌 세계 (변수와 생성자)

Swift의 '현대적'인 문법을 알게된 것도 잠시, 곧바로 또 다른 혼란에 빠졌다. 변수를 선언하는 방식부터가 자바와는 정반대였다. 자바에서는 `int number = 10;` 처럼 **"타입이 먼저 오고 이름이 뒤따르는"** 방식이 당연했다. 하지만 Swift에서는 `let number: Int = 10` 이었다.

이 어색함은 함수나 객체 생성자를 정의할 때 정점에 달했다. 예를 들어, 내가 짠 `LottoResults` 구조체를 생성하는 코드를 보자. 

```java
// Java 방식 (생성자 정의)
public LottoResults(List<Lotto> lottos, WinningLotto winningNumbers) {
    // ...
}
```

```swift
// Swift 방식 (Initialzer 정의)
init(lottos: [Lotto], winningNumbers: WinningLotto) {
    // ...
}
```

그리고 이 생성자를 **호출**하는 부분은 이렇다.

```swift
// Swift 방식 (호출)
let results = LottoResults(lottos: self.lottos, winningNumbers: winning)
```

자바의 명료한 `타입 이름` 문법에 익숙해진 나에게는 이 낯선 구조가 마치 모든 게 거꾸로 뒤집힌 것처럼 느껴졌다. 변수를 선언할 땐 `이름: 타입` 순서이면서, 생성자 파라미터는 `(외부이름 내부이름: 실제 객체)` 순서로 들어오는 이 모든 규칙이 처음에는 너무 어색하고 혼란스러웠다.

<br>

### 5-5. "Swifty"한 문법 3: 값이 있을 수도, 없을 수도 (Optional과 guard let)

`ViewController`를 만들면서, `private var winningLotto: WinningLotto?`처럼, 내가 만든 도메인 객체를 옵셔널(`?`)로 선언해야 하는 순간들을 마주했다.  `winningLotto` 객체는 `ViewController`가 처음 켜질 때부터 존재하는 값이 아니었다. 이 값은 **사용자가 구매 버튼을 누르고 (이벤트 1), 당첨 번호를 입력하고 (이벤트 2), 마지막으로 보너스 번호 버튼을 눌렀을 때 (이벤트 3)** 비로소 생성될 수 있는, '미래의 값'이었다. 즉, **사용자 이벤트에 의해 나중에야 값이 채워지는 상태(State)**를 표현하기 위해 옵셔널이 필수적이었던 것이다.

자바였다면 `if (winning == null) { ... }` 구문으로 처리했을 로직이, Swift에서는 `guard let`을 통해 **"조건(값이 존재함)을 만족하지 못하면 즉시 스코프를 종료한다"**는 명시적인 구조로 바뀌었다. 이 패턴을 반복해서 사용하다 보니, **실패/예외 케이스(값이 아직 없음)를 함수의 상단부로** 자연스럽게 모을 수 있었고, `guard` 문을 통과한 그 이하의 코드 블록은 **"이미 `nil`이 아님이 보장된(unwrapped) 안전한 영역"**이라는 전제 하에 코드를 작성할 수 있었다.

<br>

### 5-6. 그런데... 왜 또 체크하죠? (컴파일러의 '과잉보호')

`guard let`의 '안전한' 개념에 감탄한 것도 잠시, 나는 코드의 흐름을 보고 더 큰 혼란에 빠졌다. 내 코드는 보너스 번호가 입력되면 `didTapBonusNumberButton` 이벤트가 실행되고, 이 안에서 `handleBonusNumber()`와 `showResults()` 함수가 순서대로 호출된다.

```swift
@IBAction func didTapBonusNumberButton(_ sender: UIButton) {
    handleBonusNumber() // 1. 여기서 self.winningLotto가 세팅된다.
    showResults()       // 2. 여기서 self.winningLotto를 쓴다.
}
```

`handleBonusNumber` 함수 안에서는 `self.winningLotto = try WinningLotto(...)`를 통해 분명히 `winningLotto` 프로퍼티에 값을 할당했다. 그런데 바로 다음에 호출되는 `showResults` 함수에 들어서자마자, 나는 또다시 이 코드를 작성해야 했다.

```swift
private func showResults() {
    guard let winning = winningLotto else {
        showAlert(message: "당첨 번호와 보너스 번호가 존재하지 않습니다.")
        return
    }
    // ... (이후 로직)
}
```

자바 개발자로서의 **전에 내가 값을 넣었는데 절대 `nil`이 될 리가 없잖지만 이중 체크를 하는 것**이 혼란스러웠다. 이것이 내가 마주한 '개발자의 실행 순서'와 '컴파일러의 타입 시스템' 간의 가장 큰 간극이었다. Swift 컴파일러는 내가 `handleBonusNumber`를 성공적으로 마쳤다는 '정황'을 믿어주지 않았다. 컴파일러가 아는 유일한 사실은 `private var winningLotto: WinningLotto?`라는 선언, 즉 "이 변수는 `nil`일 수 있다"는 사실뿐이다.

만약 사용자가 잘못된 보너스 번호를 입력해 `try`가 에러를 던지고 `catch` 블록으로 빠진다면? `self.winningLotto = ...` 라인은 **실행조차 되지 않고** 함수가 종료된다. 하지만 `didTapBonusNumberButton`의 로직은 `handleBonusNumber`가 실패했든 말든, 그저 다음 줄인 `showResults()`를 호출한다.

결국 `showResults` 함수 첫 줄의 `guard let`은, 내가 "당연하다"고 생각했던 성공의 순간을 위한 코드가 아니라, 내가 "설마"라고 무시했던 **실패의 순간으로부터 NPE를 막아주는 유일한 안전장치**였던 것이다.

<br>

### 5-7. 가장 힘들었던 Auto Layout과 ScrollView

서버 개발자로서 Swift가 가장 힘들게 느껴졌던 건 단연 UI 레이아웃이었다. 특히 로또 결과가 길어지면 당연히 스크롤이 되어야 하는데, 이게 안 돼서 수많은 시간을 날렸다. 분명 `UIScrollView` 안에 라벨들을 넣었는데, 시뮬레이터에서는 꼼짝도 하지 않고, Xcode는 계속 **"Scrollable content size is ambiguous"** (스크롤 콘텐츠 크기가 모호함) 에러만 뿜어냈다.

여러 시행착오를 겪으며 iOS 레이아웃의 핵심 개념인 `safeArea`, `contentLayoutGuide`, `frameLayoutGuide`을 알게 되었고 이를 연결하는 체이닝 작업을 진행했다.

1. 스크롤될 **콘텐츠의 너비**를 `UIScrollView`의 **`Frame Layout Guide`** 너비에 고정하고,
2. `UIScrollView` 자체는 화면의 **`Safe Area`*에 맞게 배치하고,
3. 스크롤될 콘텐츠의 맨 위 요소는 **`Content Layout Guide`*의 **`top`*에 연결하고,
4. 중간 요소들을 차곡차곡 엮어 내리고,
5. **마지막으로, 가장 아래에 있는 요소를 `Content Layout Guide`의 `bottom`에 명시적으로 연결**하는 것.

바로 이 **'bottom' 연결**을 빼먹었기 때문에, 스크롤뷰는 "그래서 콘텐츠의 총 높이가 얼마인데?"를 계산하지 못했던 것이였다. 이 마지막 제약 체인을 연결하고 마침내 스크롤이 부드럽게 동작했을 때, 로직 구현과는 전혀 다른 종류의 희열과 좌절감을 동시에 느꼈다.

<br>

### 5-8. 거대 ViewController, 그리고 '왜'라는 질문

이 모든 과정을 거치고 나니, 내 `ViewController` 파일은 점점 비대해졌다. 로또 생성 로직, 당첨 번호 검증, 결과 계산과 수익률 산출, Alert 띄우기, 화면 업데이트와 상태 관리…까지 MVC 패턴이라고는 하지만, View와 도메인의 결합도가 매우 높은 **“Massive ViewController”** 상태였다. 우테코 로또 미션에서 그렇게 애써 분리했던 도메인, TDD, Inside-Out 설계는 이번 Swift 미션에서는 “다음 단계에 해야 할 일”로 밀려난 느낌이었다.

그렇다고 해서 이 과정이 쓸모없었다고 생각하지는 않는다. 오히려 콘솔이 기본이 아닌 환경에서, Storyboard와 값 타입, 옵셔널이라는 Swift 철학 위에서, 같은 “로또”라는 문제를 다시 풀어보면서, **“왜 도메인을 분리해야 하는지, 왜 테스트가 필요했는지”**를 고민하는 시간이였다.

<br>

### 🚀 1차 목표 회고

우여곡절 끝에, 비록 `ViewController` 하나에 많은 로직이 몰려 있는 형태지만, 내 손으로 만든 첫 iOS 로또 앱이 시뮬레이터 위에서 돌아가기 시작했다. 콘솔 대신 시뮬레이터를 받아들였고, 그림판처럼만 보이던 Storyboard 위에 흐름을 그릴 수 있게 되었고, `struct`/`Optional`/체이닝, 그리고 '거꾸로 뒤집힌' 문법 같은 Swift의 철학을 “그냥 외운 문법”이 아니라 실제 로또 도메인에 적용해 본 경험으로 남길 수 있었다.

이제 “화면에 띄우는 법”은 알았다. 다음 단계는 이 뒤죽박죽 섞인 코드들을 iOS 세계의 표준인 **MVVM 패턴**으로 깔끔하게 분리하는 것이다. 그리고 여기서 한 걸음 더 나아가, 단순히 당첨 번호를 입력받는 대신 **실제 동행복권 사이트의 당첨 결과를 크롤링**해서 내 앱에 연동해 보고 싶다.

<br>
<br>

## 6. MVVM 아키텍처 도입기

### 6-1. 뷰모델은 뷰를 어떻게 업데이트하는가? 클로저와 메모리 안전 설계 🔗

MVVM 패턴을 적용하면서 가장 의문이 들었던 코드는 바로 이 부분이다.

```swift
// [ViewController]

viewModel.onUpdateResultLabel = { [weak self] text in
	self?.resultLabel.text = text
}
```

```swift
// [ViewModel]

var onUpdateResultLabel: ((String) -> Void)?

func purchaseAmount(amountText: String?) {
	do {
		let parsed = try inputParser.parsePurchaseAmount(amountText)
		// ... (중략) ...
	  // 로직 처리가 끝나면 여기서 호출한다.
	  onUpdateResultLabel?("\\(parsed.lottoCount)개를 구매했습니다.")

		DispatchQueue.main.asyncAfter(deadline: .now() + self.stepDelay) {
	    self.onUpdateLottoTickets?(ticketsText)
      // ...
	  }
	}
}
```

`ViewModel`은 `ViewController`를 전혀 모른 채 독립적으로 존재하고 있다. 

> 하지만 ‘`ViewModel` 내부에서 발생한 이벤트와 데이터 처리 결과를, 도대체 어떻게 `ViewController`가 감지하고 낚아채서 가져올 수 있는가?’라는 생각이 들었다.
> 

이 부분을 찾아보니 `클로저(Closure)를 이용한 콜백 패턴`이라고 나와있었고, 아래의 순서로 위의 내용이 가능하다는 것을 보여줬다.

1. **함정 설치 :** `ViewController`는 `힙 메모리`에 '화면을 바꾸는 로직(`클로저 객체`)'을 생성하고, `그 객체의 주소값`을 `ViewModel`의 `onUpdateResultLabel`(**함수-실행 코드의 주소**를 담고 있는 변수)에 건네준다. 즉, 뷰 모델에게 "작업이 끝나면 이 주소에 있는 코드를 실행해 주세요"라고 실행 권한을 위임하는 단계다.
2. **발동 :** `ViewModel`의 `*purchaseAmount()*` 함수가 실행되면서 앞선 파싱 로직들이 완료되면, 실행 흐름은 자연스럽게 다음 줄인 `*onUpdateResultLabel*?("...")`에 도달한다. 이때 동기적(Synchronously)으로 변수에 저장된 주소지를 참조하여 함수를 호출한다. 즉, 잠시 뷰 컨트롤러가 심어둔 코드로 점프하여 실행하는 것이다. 이 과정에서 문자열을 `파라미터`로 넣어 `저장해 둔 주소지로 찾아가 함수를 실행한다.`
3. **실행과 반영 :** 뷰 모델이 함수를 실행하는 순간, CPU의 실행 흐름은 힙 메모리에 저장된 클로저 코드로 점프한다. 이 코드는 `ViewController`가 작성해 둔 것이므로, 뷰모델이 넘겨준  문자열을 받아 `self.resultLabel.text`에 집어넣는다. 결과적으로 뷰모델은 뷰를 몰라도, 연결된 **함수 포인터**를 건드리는 것만으로 화면을 갱신하게 된다.

여기서 중요한 건 클로저 함수의 `[weak self]`와 `guard let self = self else { return }` 표현이다. 

Java의 `Garbage Collector`는 순환 참조가 생겨도 “아 이건 서로만 잡고 있구나” 하면서 알아서 끊어주지만, Swift는 전혀 그렇지 않다. Swift는 `ARC`(Automatic Reference Counting)라는 훨씬 단순하고 냉정한 규칙으로 메모리를 관리한다. 즉, "Swift의 객체는 자신을 향하는 강한 참조(Strong Reference)의 개수가 0이 될 때까지, 메모리 해제 대상에서 영구적으로 제외된다.”

문제는 ViewController가 ViewModel을 강하게 잡고, ViewModel이 콜백 클로저를 강하게 잡고, 그 클로저가 다시 `self`(ViewController)를 강하게 캡처하는 구조가 생길 때다. 이렇게 되면 VC → VM → 클로저 → VC로 이어지는 원이 만들어지고, ARC 입장에서는 누구의 참조 카운트도 0이 안 되기 때문에 “아직 필요하네?” 하고 끝까지 메모리를 못 정리한다. 이게 순환 참조고, 결국 메모리 누수로 이어진다. 

```swift
ViewController ─▶ ViewModel ─▶ 클로저 ─▶ ViewController
      ▲__________________________________________▼
```

이에 `[weak self]`는 이 마지막 고리를 weak으로 바꿔서, ViewController가 진짜로 필요 없어진 순간에 깨끗하게 내려갈 수 있게 만들어주는 장치다.

그럼 여기서 한 번 더 궁금해졌다. 

> **“ViewController가 진짜로 `필요 없어진 순간`이 정확히 언제일까?”**
> 

현재 나의 앱처럼 단일 뷰 구조에서는 이 질문이 더 애매하게 느껴졌다. 왜냐하면 나는 아직 네비게이션으로 화면을 왔다 갔다 하거나, 모달을 띄웠다가 닫는 흐름을 쓰고 있지 않기 때문이다.

보통 iOS에서 `ViewController`가 “`필요 없어진 순간`”이라고 하면 이런 타이밍을 말한다.

- 네비게이션 스택에서 `pop`될 때
- 모달로 띄운 화면이 `dismiss`될 때

이 시점에 `ViewController`를 향하는 마지막 `strong` 참조가 끊어지면, **ARC**가 “이제 진짜 아무도 안 쓰네”라고 판단하고 `deinit`을 호출한 다음 메모리를 정리한다.

반면에 백그라운드로 들어가는 건 전혀 그 순간이 아니다. 홈 버튼 누르거나 앱 스위처로 다른 앱 가도, 프로세스는 여전히 살아 있고 iOS는 그냥 앱을 suspend 시켜서 CPU만 멈춰있을 뿐이다. 힙에 올라간 객체들은 그대로 남아 있다. 

진짜 메모리가 정리되는 건 시스템이 메모리 부족해서 프로세스를 강제 종료하거나, 사용자가 앱을 완전히 kill할 때뿐이다. 그때는 Root ViewController든 뭐든 통째로 날아간다.

이걸 내 현재 구조에 대입해 보면 결론이 하나 나온다. 지금 내 단일 뷰 앱에서는, 앱 시작할 때 Root ViewController + ViewModel + 클로저 세트가 한 번 만들어지고 앱이 완전히 꺼질 때까지 셋이 같이 메모리에 남아 있는 구조다. 순환 참조가 있어서 “해제 타이밍을 놓친 ViewController가 계속 쌓여간다”라는 이러한 누수는 아직 없다.

이 말만 놓고 보면, “그럼 지금은 굳이 `weak` 안 써도 되는 거 아냐?”라는 생각이 살짝 들 수도 있지만, 언제든 화면이나 모달이 확장될 수 있기에 방어적으로 설계하고 코드를 작성하는 것이 맞다고 생각했다.

<br>
<br>

### 6-2. "트래픽이 오지 않는다": 서버와 클라이언트의 결정적 차이 🤯

iOS 개발을 시작하면서 가장 낯설었던 점은 "내 코드는 언제, 어떤 계기로 실행되는가?"라는 것이었습니다. 요청의 진입점과 처리 흐름이 직관적으로 그려지지 않았기에 “요청이 어디에서 들어와서 어떻게 처리가 되는 건지” 감이 잘 오지 않았다.

나는 서버 개발자로서 클라이언트가 HTTP 요청을 보내면 → Tomcat이 스레드 하나를 할당하고 → 컨트롤러를 찾아 코드가 실행되는 것에 익숙했다.

그런데 iOS 앱을 만들어보니 이렇게 처리되지 않는 것 같다고 느꼈다. 나의 Swift 코드는 더 이상 “중앙 서버에서 클라이언트의 네트워크 요청을 기다리는” 존재가 아니었다. 대신 **각 사용자의 아이폰·아이패드라는 개별 디바이스** 안에서 독립적으로 실행된다.

따라서, 유저가 1명일 때나 100만 명일 때나 내 ViewController, ViewModel, 클로저, GCD 큐, 심지어 retain cycle로 인한 메모리 누수까지 모든 일이 **사용자 손에 들린 그 한 대의 기기, 그 RAM과 CPU 위에서만** 일어난다.

> 이후 자연스럽게 떠오른 질문은 “그럼 도대체 어떤 것(이벤트)이 내 코드를 깨우는 거지?”였다.
> 

서버의 코드가 네트워크를 통해 들어오는 '패킷(Request)'에 의해 실행된다면, 앱의 코드를 실행시키는 건 **사용자의 손가락과 하드웨어에서** 발생하는 '`로컬 이벤트`'다.

이 과정을 추상화해보면 다음과 같은 논리적 단계를 거치면서 처리가 된다.

- **하드웨어 감지:** 사용자가 화면을 터치하거나 기기를 흔들면, 하드웨어 센서가 물리적 신호를 포착한다.
- **OS의 전달:** 이 신호는 **OS 커널**에 의해 가장 먼저 감지됩니다. 커널은 이 하드웨어적 신호를 '이벤트'라는 소프트웨어적 객체로 변환하여, 현재 실행 중인 앱(Application)으로 전달한다.
- **Main RunLoop의 수신:** 앱에는 `Main RunLoop`라는 무한 루프가 돌고 있습니다. OS가 전달한 이벤트는 바로 이 루프의 입력 소스로 들어오게 된다.

여기서 서버와 가장 큰 차이가 있다. 서버는 요청마다 새로운 스레드를 할당하지만, iOS는 **`Main Thread`**라는 단 하나의 스레드가 `RunLoop`를 돌며 모든 UI 이벤트를 순차적으로 처리한다.

1. **대기 (Wait):** RunLoop는 처리할 이벤트가 없으면 대기 상태로 머문다.
2. **실행 (Execute):** 터치 이벤트가 들어오면 RunLoop가 깨어나고, 해당 이벤트와 연결된 코드(Target-Action, Delegate, Closure 등)를 Main Thread 위에서 실행한다.
3. **반복 (Loop):** 코드 실행이 끝나면 다시 다음 이벤트를 기다리는 상태로 돌아간다.

이 구조 때문에 "`Main Thread를 차단하지 말라`"는 iOS 개발의 대원칙이 생겨난다. 모든 UI 렌더링과 이벤트 처리가 Main Thread에서만 이루어지기 때문이다.

만약 버튼을 눌렀을 때 `무거운 연산`을 Main Thread에서 직접 수행하면, RunLoop가 다음 바퀴를 돌지 못해 화면이 멈추는 현상(Freezing)이 발생한다. 따라서 이를 **`GCD(Grand Central Dispatch)`**를 이용해 백그라운드 스레드로 분리해야한다.

결국 서버 개발자의 고민은 `트래픽 처리량(Throughput)`이었지만, iOS 개발자의 고민은 `사용자 경험(UX)과 UI 반응성(Responsiveness)`으로 완전히 바뀌어 버린다. 

<br>
<br>

### 6-3. 앱의 작동 원리: Xcode의 ▶︎ 버튼을 누르면 벌어지는 일 🚀

xcode에서 swift 코드를 조금 쓰다가 이런 궁금증이 생긴 적이 있었다. 

> **“Xcode에서 ▶︎(Start the active scheme)를 누른 그 다음에는, 도대체 어떤 순서로 무슨 코드들이 호출되길래 결국 `*viewDidLoad()*`와 `*bindViewModel()*`까지 도달하는 걸까?”**
> 

프로젝트를 처음 만들었을 때, 기본으로 생성되어 있었던 **`AppDelegate`, `SceneDelegate`, `ViewController`, `Main.storyboard`** 같은 알 수 없는 파일들이 도대체 어떤 역할을 하고, **어떻게 시뮬레이터를 작동시키는지** 이해하기 어려웠다

자바 개발자라면 런타임에 JVM이 올라가고 Application의 *main static 메서드*에서 코드가 시작된 다음,

```java
public class MainApplication {

	public static void main(String[] args) {
		// ...
	}
}
```

스프링이라면 ApplicationContext(스프링 컨테이너)를 생성하며 시작되는 흐름이 자연스럽게 떠오른다. 반면 iOS에서는 이 `시작 지점`이 코드에 드러나 있지 않아서, 처음에는 정말 완전히 깜깜한 느낌이었다.

하지만 iOS에서도 코드가 실행되는 명확한 시작점은 존재했다. 보이지 않던 **그 시작점**을 추적하며, 우리의 Swift 코드가 최종적으로 어떻게 호출되고 **Main Thread의 제어권**을 얻는지 파헤쳐 봤다.

Xcode에서 '▶︎' 버튼을 누르는 순간, iOS 시스템은 컴파일된 앱 바이너리를 실행한다. 이는 **서버의 컨테이너를 부팅하는 과정**과 유사하다. 모든 C 계열 프로그램처럼 iOS 앱의 시작점은 **`main()` 함수**다. 하지만 Swift에서는 이 `main()` 함수가 보통 숨겨져 있다. 이 함수 내부에서 `UIApplicationMain`이라는 C 함수를 호출하여 앱의 실행 환경을 초기화하고, Main Thread가 앱의 모든 UI와 생명주기를 담당하는 **Event Loop**를 돌리기 시작한다.

Main Thread가 생성된 후, 제어권은 앱의 두 관리자에게 전달된다.

- **`AppDelegate` (프로세스 관리):** 앱 프로세스가 켜지고(Launch), 꺼지고(Terminate), 푸시 알림을 받는 **앱 전체의 수명 주기**를 담당한다. 서버의 `main()` 메서드나 글로벌 설정을 담당하는 Configuration과 유사하다.
- **`SceneDelegate` (UI 윈도우 관리):** iOS 13 이후 도입되었으며, 하나의 화면(Window/Scene)이 언제 **앞으로(포그라운드) 튀어나와서 유저와 상호작용을 시작하는지**, 언제 **뒤로(백그라운드) 물러나서 화면에서 사라지는지** 같은 UI 단위의 수명 주기를 관리한다. 예를 들어 사용자가 홈 화면으로 나가거나 다른 앱으로 전환할 때, SceneDelegate는 해당 화면이 **백그라운드로 내려가는 순간**에 맞춰 상태 저장, 정리 작업 등을 할 수 있는 훅을 제공한다.

Main Thread는 이제 `SceneDelegate`의 지시에 따라 사용자에게 보여줄 첫 화면을 그리기 시작한다. 먼저 `SceneDelegate`는 앱의 **Root View Controller**를 결정한다. 이때 **`Main.storyboard`** 파일이 사용된다.

- **Storyboard 역할:** `Main.storyboard`는 단순한 `XML 설계도`이다.
- **Main Thread의 역할:** Main Thread는 이 XML을 읽어 `UILabel`, `UIButton`, `ViewController` 같은 객체들을 `Heap 메모리에 생성(Instantiation)`하고 초기값을 설정한다. 이 순간 정적인 설계도가 동적인 객체로 전환된다.

내가 만든 `LottoViewController`는 애플이 제공하는 `UIViewController`를 상속받는다. 이 상속 구조가 프레임워크가 정한 생명주기 안에 내 코드를 안전하게 끼워 넣을 수 있게 해준다.

- **`*override func viewDidLoad()*`:** 시스템이 `ViewController`의 모든 UI 객체(View)를 메모리에 성공적으로 로드하고 연결한 직후, **딱 한 번** 이 메서드를 호출한다. 이것이 바로 "`UI 설정 준비 완료`"를 알리는 `후크(Hook)`다. Java/Spring의 `@PostConstruct` 시점과 유사하다.

우리가 `*viewDidLoad()*` 내부에 `*bindViewModel()*` 같은 코드를 넣는 이유는 바로 이 시점이 `ViewController`**의 초기 설정과** `ViewModel`**의 연결을 시작하기에 가장 안전하고 적절한 지점**이기 때문이다.

- **연결:** `bindViewModel()`이 실행되는 순간, 우리가 작성한 클로저가 힙 메모리에 할당되고 `ViewModel`의 콜백 변수와 연결된다.
- **대기:** 이 시점 이후, `Main Thread`는 `Event Loop`를 돌며 사용자 터치라는 '로컬 이벤트'가 발생하기를 기다리는 대기 상태로 진입한다.

<br>
<br>

### 6-4. MVVM의 적용: 역할에 맞게 분리 ⚔️

로또 미션을 진행하면서 내가 마주친 구조적 문제는 바로 **책임의 비대화**였다.

처음에는 모든 비즈니스 로직과 UI 조작을 `ViewController` 하나에 몰아넣고도 코드가 돌아갔다. 텍스트 필드 문자열 파싱, 로또 번호 계산, `UILabel.text` 업데이트까지 전부 `ViewController`의 몫이었다. 이는 곧 **Massive ViewController**라는 결과로 이어졌다.

MVVM 구조를 도입하면서 이 문제를 해결하려 했고, 나는 "화면과 관련 없는 모든 것"을 `ViewModel`로 분리했다. 금액 검증, 로또 번호 생성, 심지어 결과 출력용 문자열을 조립하는 작업까지 모두 `ViewModel` 내부에서 처리했다. 

하지만 ViewModel 클래스가 방대해지면서 문제가 발생했다. ViewModel은 이제 화면의 상태 관리, 입력 처리, 도메인 로직 수행, 출력 문자열 포맷팅까지 모든 것을 담당하는 새로운 병목 지점(Bottleneck)이 되어버린 것이다.

즉, "`Massive ViewController`를 해체했더니, 그 모든 책임이 `ViewModel`로 고스란히 옮겨간 것에 불과하다"는 깨달음으로 이어졌다. `ViewModel`은 순수한 데이터와 로직 조정만을 담당해야 하는데, **입력 파싱, 계산, 그리고 최종적인 포맷팅**까지 관여하면서 새로운 **Massve ViewModel**로 비대해져 버린 것이다. 

여기서 **`ViewModel`의 역할과 책임**에 대해 근본적인 고민이 생겼다.

> `ViewModel`이 순수한 데이터를 조정하는 역할이라면, **입력 파싱이나 복잡한 출력 포맷팅 같은 작업들은 유틸 성격으로 분리하는 작업**이 필요하지 않을까?
> 

이러한 의문 끝에, 나는 단일 책임 원칙(SRP)을 기반으로 `ViewModel`의 역할을 "조정(Orchestration)"으로 한정하고, 입출력과 포맷팅 작업을 유틸리티 계층으로 분리하는게 좋을 것 같다고 판단했다.

그리고 아래와 같이 역할에 맞게 코드를 분리했다.

1. LottoViewModel (조정자/Presentation Layer)

`ViewModel`은 **데이터를 직접 가공하는 대신** 필요한 외부 컴포넌트를 호출하고 흐름을 제어하는 최종 책임자가 되었다.

- **역할:** **상태 관리 및 흐름 제어.** 사용자 입력(메서드)을 받고 내부 상태(`lottos`, `purchaseAmount`)를 변경하며, 외부 `Parser`와 `Formatter`를 호출하여 결과를 얻는다. 이 결과를 `Closure` I/O를 통해 `ViewController`에게 전달하는 최종적인 책임(`onUpdateResultLabel`, `onShowResults`)을 진다.
- **특징:** 복잡한 비즈니스 플로우(구매 → 생성 → 당첨 번호 입력 → 결과 출력)와 **비동기 타이밍**(`DispatchQueue.main.asyncAfter`)을 관리한다.
- **Java 비유:** `@Controller`나 `@Service`에서 다른 `Repository`나 `Utility`를 주입받아 **업무 흐름**을 정의하는 역할.

1. LottoInputParser (경계 처리/Input Service)

`InputParser`는 시스템의 **입력 경계선**을 담당하는 Service 계층의 역할을 수행한다.

- **역할:** **Input String을 Domain Object로 변환.** 사용자에게 받은 원시적인 문자열(`numbersText`)을 도메인이 요구하는 엄격한 규칙을 갖춘 객체(`Lotto`, `Money`)로 안전하게 변환하는 경계층의 책임.
- **특징:** 모든 유효성 검사(`InputValidator`)를 수행하며, 유효하지 않은 입력에 대해서는 `try/catch`를 통해 명확한 **도메인 오류**를 던진다. `ViewModel`은 이미 검증된 객체만 받게 되어 로직 수행이 단순화된다.
- **Java 비유:** Input DTO를 Domain Entity로 변환하는 Service Layer의 역할.

1. LottoResultFormatter (출력 변환/Presentation Utility)

`ResultFormatter`는 **출력 전용 유틸리티**로, 화면에 보여주기 직전의 마지막 가공을 담당한다.

- **역할:** **Domain Object를 Display String으로 변환.** 순수한 비즈니스 로직(당첨 등수)이 끝난 후, 그 결과를 최종적으로 사용자 인터페이스에 맞는 형태로 가공한다.
- **특징:** `LottoResults` 객체를 받아 **수익률 포맷팅**(`String(format: "%.1f")`), **줄 바꿈 및 콤마 처리**(`joined(separator: "\n")`), **통계 테이블 형식**(`finalResultText`) 등 출력에 관련된 모든 것을 담당한다.
- **Java 비유:** DTO를 View에 맞게 최종 포맷팅하는 `Presenter`나 `Mapper`의 역할.

이러한 세분화 덕분에 `ViewModel`은 **순수한 조정자** 역할에만 집중할 수 있게 되었다.

<br>
<br>

## 🔔 기존의 요구사항은 아래와 동일

[🎰 로또 게임 (Lotto Game)](https://github.com/JohnPrk/java-lotto-8)

<br>
<br>
