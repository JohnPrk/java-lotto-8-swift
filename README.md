# Swift Lotto 🎱

> 이번 Swift 로또 미션은, 아래 5가지의 흐름으로 진행하고 기록한다.
> 

<br>
<br>

## 1. 왜 스위프트를 선택했는가?

우테코 3주차 로또 미션을 자바로 구현하면서, 나는 **도메인 설계, Inside-Out, TDD 등**에 꽤 많은 고민을 쏟았다. 하지만 이 번 오픈 미션에서는 똑같은 “로또”라는 문제를, **완전히 다른 언어인 스위프트와 이에 맞는 철학** 위에서 구현해보면서 내가 가지고 있는 언어와 객체지향의 원리의 장, 단점을 배워보고 싶었다.

스위프트를 선택한 이유를 정리하면:

1. 순수 객체지향 철학을 가진 자바만 써오다 보니, 내가 당연하게 여기던 “객체지향적인 설계”가 정말 항상 좋은 선택인지 궁금했다. 그래서 함수형·프로토콜 지향·값 타입이 섞여 있는 Swift를 써 보면서 **객체지향의 강점과 한계를 바깥쪽에서 다시 바라보고 싶었다.**
2. 자바식 설계 원칙을 그대로 이식하는 게 아니라, **스위프트가 권장하는 “Swifty한 스타일”이 무엇인지** 직접 느껴보고 싶었다. 언어가 나에게 요구하는 사고방식(값 타입 중심, 옵셔널, 프로토콜 지향 등)을 몸으로 익혀보고, 도메인 설계를 거기에 어떻게 녹일 수 있을지 실험해 보고 싶었다.
3. Swift는 자바에 비해 레퍼런스나 예제가 상대적으로 적다고 느꼈다. 그래서 공식 문서와 몇 안 되는 자료들만으로 **학습 계획을 스스로 세우고, 작은 단위 목표를 쪼개서 달성하는 연습**을 해보고 싶었다. 단순히 “검색하면 다 나오는 언어”가 아니라, **스스로 길을 그려가야 하는 환경에서 얼마나 배울 수 있는지**도 확인해 보고 싶었다.
4. 예전에 실제 앱을 출시할 때 iOS 클라이언트 개발자와 협업을 해본 적이 있다. 그때 “서버/백엔드 쪽 시선”만으로는 이해하지 못하는 부분들이 분명히 있다는 걸 느꼈다. 이번 기회에 직접 Swift를 만져보면서, **앞으로 클라이언트 개발자들과 소통할 때 기반이 되는 공통 언어**를 조금이라도 가져가고 싶었다.
5. 언젠가는 **혼자서 작은 앱 하나를 처음부터 끝까지 만들어 보고 싶다**는 욕심도 있다. 이번 Swift 로또 도전은, 나에게는 “실제 앱 개발로 가기 전, 스위프트 생태계를 맛보는 첫 실험”에 가깝다.
6. 무엇보다, 미션의 취지(도전 정신)에 맞게 **“새로운 언어(Swift) + IDE(Xcode) + iOS UI 프레임워크(Storyboard 기반 UIKit)”**을 한꺼번에 부딪혀 보고 싶었다.  

그래서 목표를 이렇게 잡았다.

> 1차 목표: **Storyboard 기반으로 로또 기본 기능이 동작하는 iOS 앱 만들기**
> 
> 2차 목표: **MVVM 구조로 화면과 도메인 로직을 분리·리팩터링하기**
> 
> 3차 목표: **실제 로또 당첨 번호 데이터를 크롤링해서 앱에 연동해 보기**
<br>
<br>

## 2. 스위프트가 자바가 다른 점이 무엇일까?

(이곳에 Swift와 Java의 철학, 문법, 패러다임 차이점에 대한 분석 내용을 채워나갈 예정)

<br>
<br>

## 3. 미션의 목표와 한계

(이곳에 이번 미션을 통해 달성하고자 하는 구체적인 학습 목표와 시간/환경적 한계를 명시할 예정)

<br>
<br>

## ~~4. 첫 번째 목표: Swift로 콘솔 로또 게임 구현~~

원래는 자바와 마찬가지로 **콘솔 기반 로또 게임을 Swift로 먼저 옮겨보는 것**을 목표로 잡았으나, Xcode에서 기본으로 제공하는 템플릿이 iOS 앱(Storyboard/SwiftUI 기반)이라 별도의 콘솔 프로젝트 구성이 필요했다.  

이번에는 **iOS UI 구현에 집중**하기로 하여 콘솔 버전 단계는 생략하고, 바로 Storyboard 기반 로또 앱 구현(5번)으로 넘어가기로 했다.

<br>
<br>

## 5. 두 번째 목표: storyboard로 로또 UI 만들어보기

### 5-1. 콘솔창이... 없다? (Xcode와의 첫 만남)

자바 개발자인 나에게 '프로그래밍의 시작'은 언제나 `public static void main`이었고, 결과 확인은 검은색 콘솔창(Terminal)이었다. **그래서 처음엔 이번 로또 미션도 Swift로 간단하게 콘솔창에서 입출력을 받는 버전을 먼저 만들려고 했다.**

하지만 Xcode를 처음 켜고 프로젝트를 생성했을 때, 입출력을 담당하는 그 '검은색 콘솔창'이라는 개념 자체가 애초에 보이지 않았고, `ViewController`, `AppDelegate`, `SceneDelegate` 같은 낯선 파일만 있었다. 심지어 `System.out.println`을 어디에 찍어야 하는지도 막막했다.

내가 짠 코드가 콘솔이 아닌 '아이폰 시뮬레이터'라는 가상의 기계 위에서 돌아간다는 사실을 받아들이는 것부터가 시작이었다. 이걸 이해하고 나서야, 나는 자바에서 하던 방식(도메인 → main → 콘솔 I/O)을 잠시 내려놓고, **화면(ViewController)부터 한번 따라가 보자**” 라는 마음으로 방향을 틀었다.

<br>

### 5-2. 그림 그리기인가, 코딩인가? (Storyboard의 충격)

그다음 문화 충격은 **Storyboard**였다. 자바나 Spring에서는 모든 흐름이 온전히 코드 안에서 결정된다. 함수 호출, 객체 주입, 흐름 제어 같은 것들은 전부 키보드 위에서 이뤄졌다. 그런데 iOS에서는 시작부터 방식이 달랐다. 오브젝트(버튼이나 입력창)를 마우스로 드래그 앤 드롭해서 화면에 올려두고, 다시 그 요소들을 `@IBOutlet`, `@IBAction`과 같은 형태로 컨트롤 드래그로 코드에 연결해 줘야 했다.

이러한 연결은 단순한 “편의 기능”이 아니었다. `@IBOutlet` 프로퍼티만 선언해 두고 Storyboard에서 실제 코드와 매핑을 해두지 않으면, 빌드나 실행 과정에서 연결되지 않은 아울릿에 대한 예외가 발생하면서 앱이 그대로 죽어버렸다. Storyboard 위에 버튼을 올려놓았더라도, `@IBAction`으로 액션을 묶어두지 않으면 실제 앱에서는 버튼을 눌러도 아무 동작도 일어나지 않았다. 화면에 **“보이기만 하는 버튼”**과 **“실제로 반응하는 버튼”**이 완전히 다른 존재라는 것을 알게 되었다.

레이아웃을 잡는 과정에서 말하는 ‘체이닝’도 마찬가지였다. 입력창 옆에 버튼이 오도록 배치하고 싶다면, 또다시 컨트롤 드래그로 두 요소 사이에 **‘제약(Constraint)’**이라는 보이지 않는 선을 걸어줘야 했다. 로또 앱의 흐름이 버튼, 텍스트 필드(입력창), 레이블 등 여러 UI 요소들로 체인처럼 이어지다 보니, 이 연결 관계를 하나라도 빼먹거나 잘못 걸어두면 버튼은 화면 밖으로 밀려나고, 레이블은 서로 꼬이면서 화면이 엉망이 되었다.

**결국** 이 모든 그림판이 제멋대로처럼 느껴졌다. 스토리보드 캔버스에 보이는 이미지만 보면 레이아웃이 그럴듯해 보이는데, 막상 시뮬레이터를 켜면 실제 렌더링된 결과는 전혀 다른 모습으로 나타났다. 제약(Constraint)이 하나라도 빠지거나 꼬이면, 스토리보드에서 본 것과는 전혀 다른 화면이 펼쳐지는 경험을 여러 번 반복해야 했다.

이 과정 속에서, iOS 개발에서는 ‘보이는 화면’과 ‘코드로 작성된 논리’를 둘 다 관리하고, 둘 사이의 연결 상태까지 끝까지 책임져야 한다는 것을 알게되었다.

<br>

### 5-3. "Swifty"한 문법을 몸으로 느끼기

처음 Swift로 코드를 짤 때는, 솔직히 말하면 거의 Java 코드와 비슷하다고 느꼈다. 변수 타입의 순서만 바꾸고, 세미콜론만 지운 것 같은 느낌이었다. 그런데 로또 미션을 진행하면서, "아, 이 언어는 생각하는 방식 자체가 다르구나"를 몸으로 느낀 순간이 몇 번 있었다.

**첫 번째는 체이닝(Chaining)이었다.** 자바였다면 로또 번호를 출력하기 위해 `StringBuilder`를 만들고, 반복문을 돌면서 `append`를 호출했을 것이다. 하지만 Swift에서는 자연스럽게 이런 코드가 나왔다.

```swift
let ticketsText = lottos
    .map { "[\($0.getNumbers().map { String($0) }.joined(separator: ", "))]" }
    .joined(separator: "\n")
```

`map`으로 변환하고, 그 안에서 다시 `map`/`joined`를 쓰고, 마지막에 또 `joined`로 묶는 이 방식. `+`로 문자열을 계속 "더한다"기보다, `\()`(문자열 보간)를 이용해 데이터를 **"변환해서 흘려보내는"** 쪽에 가까웠다.

**두 번째는 `struct`였다.** `struct`도 처음에는 당황스러웠다. 자바에서는 `LottoTicket.java` 파일 안에 `public class LottoTicket`이 있는 것이 당연했는데, Swift에서는 그냥 `LottoTicket.swift` 파일 안에 `struct LottoTicket` 하나만 있어도 아무 문제가 없었다.

<br>


### 5-4. "Swifty"한 문법 2: 거꾸로 뒤집힌 세계 (변수와 생성자)

Swift의 '현대적'인 문법을 알게된 것도 잠시, 곧바로 또 다른 혼란에 빠졌다. 변수를 선언하는 방식부터가 자바와는 정반대였다. 자바에서는 `int number = 10;` 처럼 **"타입이 먼저 오고 이름이 뒤따르는"** 방식이 당연했다. 하지만 Swift에서는 `let number: Int = 10` 이었다.

이 어색함은 함수나 객체 생성자를 정의할 때 정점에 달했다. 예를 들어, 내가 짠 `LottoResults` 구조체를 생성하는 코드를 보자. 

```java
// Java 방식 (생성자 정의)
public LottoResults(List<Lotto> lottos, WinningLotto winningNumbers) {
    // ...
}
```

```swift
// Swift 방식 (Initialzer 정의)
init(lottos: [Lotto], winningNumbers: WinningLotto) {
    // ...
}
```

그리고 이 생성자를 **호출**하는 부분은 이렇다.

```swift
// Swift 방식 (호출)
let results = LottoResults(lottos: self.lottos, winningNumbers: winning)
```

자바의 명료한 `타입 이름` 문법에 익숙해진 나에게는 이 낯선 구조가 마치 모든 게 거꾸로 뒤집힌 것처럼 느껴졌다. 변수를 선언할 땐 `이름: 타입` 순서이면서, 생성자 파라미터는 `(외부이름 내부이름: 실제 객체)` 순서로 들어오는 이 모든 규칙이 처음에는 너무 어색하고 혼란스러웠다.

<br>

### 5-5. "Swifty"한 문법 3: 값이 있을 수도, 없을 수도 (Optional과 guard let)

`ViewController`를 만들면서, `private var winningLotto: WinningLotto?`처럼, 내가 만든 도메인 객체를 옵셔널(`?`)로 선언해야 하는 순간들을 마주했다.  `winningLotto` 객체는 `ViewController`가 처음 켜질 때부터 존재하는 값이 아니었다. 이 값은 **사용자가 구매 버튼을 누르고 (이벤트 1), 당첨 번호를 입력하고 (이벤트 2), 마지막으로 보너스 번호 버튼을 눌렀을 때 (이벤트 3)** 비로소 생성될 수 있는, '미래의 값'이었다. 즉, **사용자 이벤트에 의해 나중에야 값이 채워지는 상태(State)**를 표현하기 위해 옵셔널이 필수적이었던 것이다.

자바였다면 `if (winning == null) { ... }` 구문으로 처리했을 로직이, Swift에서는 `guard let`을 통해 **"조건(값이 존재함)을 만족하지 못하면 즉시 스코프를 종료한다"**는 명시적인 구조로 바뀌었다. 이 패턴을 반복해서 사용하다 보니, **실패/예외 케이스(값이 아직 없음)를 함수의 상단부로** 자연스럽게 모을 수 있었고, `guard` 문을 통과한 그 이하의 코드 블록은 **"이미 `nil`이 아님이 보장된(unwrapped) 안전한 영역"**이라는 전제 하에 코드를 작성할 수 있었다.

<br>

### 5-6. 그런데... 왜 또 체크하죠? (컴파일러의 '과잉보호')

`guard let`의 '안전한' 개념에 감탄한 것도 잠시, 나는 코드의 흐름을 보고 더 큰 혼란에 빠졌다. 내 코드는 보너스 번호가 입력되면 `didTapBonusNumberButton` 이벤트가 실행되고, 이 안에서 `handleBonusNumber()`와 `showResults()` 함수가 순서대로 호출된다.

```swift
@IBAction func didTapBonusNumberButton(_ sender: UIButton) {
    handleBonusNumber() // 1. 여기서 self.winningLotto가 세팅된다.
    showResults()       // 2. 여기서 self.winningLotto를 쓴다.
}
```

`handleBonusNumber` 함수 안에서는 `self.winningLotto = try WinningLotto(...)`를 통해 분명히 `winningLotto` 프로퍼티에 값을 할당했다. 그런데 바로 다음에 호출되는 `showResults` 함수에 들어서자마자, 나는 또다시 이 코드를 작성해야 했다.

```swift
private func showResults() {
    guard let winning = winningLotto else {
        showAlert(message: "당첨 번호와 보너스 번호가 존재하지 않습니다.")
        return
    }
    // ... (이후 로직)
}
```

자바 개발자로서의 **전에 내가 값을 넣었는데 절대 `nil`이 될 리가 없잖지만 이중 체크를 하는 것**이 혼란스러웠다. 이것이 내가 마주한 '개발자의 실행 순서'와 '컴파일러의 타입 시스템' 간의 가장 큰 간극이었다. Swift 컴파일러는 내가 `handleBonusNumber`를 성공적으로 마쳤다는 '정황'을 믿어주지 않았다. 컴파일러가 아는 유일한 사실은 `private var winningLotto: WinningLotto?`라는 선언, 즉 "이 변수는 `nil`일 수 있다"는 사실뿐이다.

만약 사용자가 잘못된 보너스 번호를 입력해 `try`가 에러를 던지고 `catch` 블록으로 빠진다면? `self.winningLotto = ...` 라인은 **실행조차 되지 않고** 함수가 종료된다. 하지만 `didTapBonusNumberButton`의 로직은 `handleBonusNumber`가 실패했든 말든, 그저 다음 줄인 `showResults()`를 호출한다.

결국 `showResults` 함수 첫 줄의 `guard let`은, 내가 "당연하다"고 생각했던 성공의 순간을 위한 코드가 아니라, 내가 "설마"라고 무시했던 **실패의 순간으로부터 NPE를 막아주는 유일한 안전장치**였던 것이다.

<br>

### 5-7. 가장 힘들었던 Auto Layout과 ScrollView

서버 개발자로서 Swift가 가장 힘들게 느껴졌던 건 단연 UI 레이아웃이었다. 특히 로또 결과가 길어지면 당연히 스크롤이 되어야 하는데, 이게 안 돼서 수많은 시간을 날렸다. 분명 `UIScrollView` 안에 라벨들을 넣었는데, 시뮬레이터에서는 꼼짝도 하지 않고, Xcode는 계속 **"Scrollable content size is ambiguous"** (스크롤 콘텐츠 크기가 모호함) 에러만 뿜어냈다.

여러 시행착오를 겪으며 iOS 레이아웃의 핵심 개념인 `safeArea`, `contentLayoutGuide`, `frameLayoutGuide`을 알게 되었고 이를 연결하는 체이닝 작업을 진행했다.

1. 스크롤될 **콘텐츠의 너비**를 `UIScrollView`의 **`Frame Layout Guide`** 너비에 고정하고,
2. `UIScrollView` 자체는 화면의 **`Safe Area`*에 맞게 배치하고,
3. 스크롤될 콘텐츠의 맨 위 요소는 **`Content Layout Guide`*의 **`top`*에 연결하고,
4. 중간 요소들을 차곡차곡 엮어 내리고,
5. **마지막으로, 가장 아래에 있는 요소를 `Content Layout Guide`의 `bottom`에 명시적으로 연결**하는 것.

바로 이 **'bottom' 연결**을 빼먹었기 때문에, 스크롤뷰는 "그래서 콘텐츠의 총 높이가 얼마인데?"를 계산하지 못했던 것이였다. 이 마지막 제약 체인을 연결하고 마침내 스크롤이 부드럽게 동작했을 때, 로직 구현과는 전혀 다른 종류의 희열과 좌절감을 동시에 느꼈다.

<br>

### 5-8. 거대 ViewController, 그리고 '왜'라는 질문

이 모든 과정을 거치고 나니, 내 `ViewController` 파일은 점점 비대해졌다. 로또 생성 로직, 당첨 번호 검증, 결과 계산과 수익률 산출, Alert 띄우기, 화면 업데이트와 상태 관리…까지 MVC 패턴이라고는 하지만, View와 도메인의 결합도가 매우 높은 **“Massive ViewController”** 상태였다. 우테코 로또 미션에서 그렇게 애써 분리했던 도메인, TDD, Inside-Out 설계는 이번 Swift 미션에서는 “다음 단계에 해야 할 일”로 밀려난 느낌이었다.

그렇다고 해서 이 과정이 쓸모없었다고 생각하지는 않는다. 오히려 콘솔이 기본이 아닌 환경에서, Storyboard와 값 타입, 옵셔널이라는 Swift 철학 위에서, 같은 “로또”라는 문제를 다시 풀어보면서, **“왜 도메인을 분리해야 하는지, 왜 테스트가 필요했는지”**를 고민하는 시간이였다.

<br>

### 🚀 1차 목표 회고

우여곡절 끝에, 비록 `ViewController` 하나에 많은 로직이 몰려 있는 형태지만, 내 손으로 만든 첫 iOS 로또 앱이 시뮬레이터 위에서 돌아가기 시작했다. 콘솔 대신 시뮬레이터를 받아들였고, 그림판처럼만 보이던 Storyboard 위에 흐름을 그릴 수 있게 되었고, `struct`/`Optional`/체이닝, 그리고 '거꾸로 뒤집힌' 문법 같은 Swift의 철학을 “그냥 외운 문법”이 아니라 실제 로또 도메인에 적용해 본 경험으로 남길 수 있었다.

이제 “화면에 띄우는 법”은 알았다. 다음 단계는 이 뒤죽박죽 섞인 코드들을 iOS 세계의 표준인 **MVVM 패턴**으로 깔끔하게 분리하는 것이다. 그리고 여기서 한 걸음 더 나아가, 단순히 당첨 번호를 입력받는 대신 **실제 동행복권 사이트의 당첨 결과를 크롤링**해서 내 앱에 연동해 보고 싶다.

<br>
<br>

## 6. MVVM 아키텍처 도입기

(MVVM 아키텍처를 사용해서 코드를 더 깔끔하게 만드는 과정을 작성할 예정)

<br>
<br>

## 🔔 기존의 요구사항은 아래와 동일

[🎰 로또 게임 (Lotto Game)](https://github.com/JohnPrk/java-lotto-8)

<br>
<br>
